package integration

public
	with abstracts;
	with sensor;
	with controller;
	with data_types;
	with platform;
	with EMV2;
	with states;
	with Cheddar_Properties;
	with Resolute_Stdlib;
	with SEI;
	
	annex Resolute{**
			SystemWideReq1() <= ** "All threads have a period" ** 
 				forall (t: thread). HasPeriod(t)
 
 			HasPeriod(t : thread) <= ** "Thread " t " has a period" ** 
 				has_property(t,Timing_Properties::Period)
	**};
	
	system cacc_rt extends abstracts::cacc
		features
			sensed_speed:in data port data_types::speed;
			sensed_speed_limit:in data port data_types::speed; 
			sensed_position:in data port data_types::gpsPosition;
			gap:in data port;
			gapLimit: in data port;
			power: in data port;
		
			
	end cacc_rt;
	
	system implementation cacc_rt.devices extends abstracts::cacc.devices
		subcomponents
			vehicle_controller: 	refined to process control_rt.impl   	  {Classifier_Substitution_Rule => Type_Extension;};
			interface_controller:	refined to process interface_controller_rt.impl;
			radar_sensor:		 	refined to device  radarSensor_rt.impl    {Classifier_Substitution_Rule => Type_Extension;};
			radar_handler:			refined to system  radar_handler.impl;
			camera_sensor:			refined to device  cameraSensor_rt.impl   {Classifier_Substitution_Rule => Type_Extension;};
			camera_handler:			refined to system  camera_handler.impl;
			speedometer:		 	refined to device  speedometer_rt.impl 	  {Classifier_Substitution_Rule => Type_Extension;};
			speedometer_handler:	refined to system  speedometer_handler.impl;
			gps:		 		 	refined to device  gps_rt.impl 		   	  {Classifier_Substitution_Rule => Type_Extension;};
			gps_handler:			refined to system  gps_handler.impl;
			user_interface:	 		refined to device  user_interface_rt.impL {Classifier_Substitution_Rule => Type_Extension;};
			logger: 		 		refined to system  logger_rt.impl;
			this_bus:				bus 	  			platform::generic_bus;
			first_virtual_bus:		virtual bus 		platform::sensor_data_bus; 
			second_virtual_bus:		virtual bus 		platform::sensor_data_bus;  
			this_processor:			processor 			platform::generic_cpu{Cheddar_Properties::Scheduling_Protocol=>(RMS);};
			this_memory: 			memory 	  			platform::Ram.impl;
			throttle_actuator:		refined to device throttle_actuator_rt.impl {Classifier_Substitution_Rule => Type_Extension;};
			brake_actuator:		    refined to device brake_rt.impl 			{Classifier_Substitution_Rule => Type_Extension;};
			speed_controller:		refined to process speed_controller_rt.impl;	
			states:					system states::controller.impl;	
		
		connections
			bus_radar: 					bus access this_bus<->radar_sensor.BA;
			bus_camera: 				bus access this_bus<->camera_sensor.BA;
			bus_gps: 					bus access this_bus<->gps.BA;
			bus_speedometer: 			bus access this_bus<->speedometer.BA;
			bus_UI: 					bus access this_bus<->user_interface.BA;
			bus_processor:				bus access this_bus<->this_processor.net;
			bus_memory:					bus access this_bus<->this_memory.BA;	
			brake_cont_conn:			port brake_actuator.brake_failed->vehicle_controller.brake_failed;
			
			controller_driverSelection: port vehicle_controller.driverSelection -> states.driverSelection;
			controller_targetSpeed:     port vehicle_controller.targetSpeed -> states.targetSpeed;
			controller_actualSpeed:     port vehicle_controller.actualSpeed -> states.actualSpeed;
			controller_gap:     		port vehicle_controller.gap -> states.gap;
			
		properties
			-- bound thread to the processor
			Allowed_Processor_Binding => (reference(this_processor)) applies to vehicle_controller.thread_radar;
			Allowed_Processor_Binding => (reference(this_processor)) applies to vehicle_controller.thread_camera;
			Allowed_Processor_Binding => (reference(this_processor)) applies to vehicle_controller.thread_gps;
			-- bound code/data within the controller to memory
			Actual_Memory_Binding => (reference(this_memory)) applies to vehicle_controller;
			
		annex Resolute{**
				
		--	prove(print_aadl(this))
		prove (SystemWideReq1())
			
			
			**};
		
		annex EMV2 {**
			use types error_library; 
			use behavior error_library::stateMachine;
			
			composite error behavior
				states
					[radar_handler.Failed and camera_handler.Failed and gps_handler.Failed and speedometer_handler.Failed]-> Failed;
					[radar_handler.Failed and camera_handler.Failed]-> Failed;
					[radar_handler.Failed or camera_handler.Failed]->  Operational;
					[radar_handler.Operational and camera_handler.Operational and gps_handler.Operational and speedometer_handler.Operational]-> Operational;
			end composite;	
			**};
		
	end cacc_rt.devices;
	 
	-- radar
	device radarSensor_rt extends sensor::generic_sensor
		features
			sensor_data_out: refined to out data port data_types::radar_info;
			BA: requires bus access platform::generic_bus{SEI::PowerBudget=>5.0W;};
		
		annex EMV2 {**
			use types error_library;	
				error propagations
				sensor_data_out : out propagation {InvalidValue};
			flows
				ef0 : error source sensor_data_out{InvalidValue};
			end propagations;
		
			properties	
				emv2::hazards => 
					([	failure => "InvalidValue";
						description => "Invalid distance sent by the radar";
					])
					applies to sensor_data_out.invalidvalue;
		**};
	end radarSensor_rt;
	
	device implementation radarSensor_rt.impl extends sensor::generic_sensor.impl
	end radarSensor_rt.impl;
	
	system radar_handler extends sensor::generic_sensor_handler
	end radar_handler;
	
	system implementation radar_handler.impl extends sensor::generic_sensor_handler.impl
	end radar_handler.impl;
	
	-- camera
	device cameraSensor_rt extends sensor::generic_sensor
		features
			sensor_data_out: refined to out data port data_types::picture;
			BA: requires bus access platform::generic_bus{SEI::PowerBudget=>5.0W;};
			
		annex EMV2 {**
			use types Error_library; 
		
			error propagations
				sensor_data_out : out propagation {InvalidValue};
			flows
				ef0 : error source sensor_data_out{InvalidValue};
			end propagations;
			properties
				emv2::hazards => 
					([	failure => "InvalidValue";	
						description => "Invalid data from the camera";
						comment => "Would impact the detection of obstacle if the camera is not working as well";
					])
			applies to sensor_data_out.novalue;

		**};
	end cameraSensor_rt;
	
	device implementation cameraSensor_rt.impl extends sensor::generic_sensor.impl
	end cameraSensor_rt.impl;
	
	system camera_handler extends sensor::generic_sensor_handler
	end camera_handler;
	
	system implementation camera_handler.impl extends sensor::generic_sensor_handler.impl
	end camera_handler.impl;
	
	-- gps
	device gps_rt extends sensor::generic_sensor
		features
			sensor_data_out: refined to out data port data_types::gpsPosition;
			BA: requires bus access platform::generic_bus{SEI::PowerBudget=>5.0W;};
		annex EMV2 {**
			use types error_library;	
				error propagations
				sensor_data_out : out propagation {InvalidValue};
			flows
				ef0 : error source sensor_data_out{InvalidValue};
			end propagations;
		
			properties	
				emv2::hazards => 
					([	failure => "InvalidValue";
						description => "Invalid data sent by the gps";
					])
					applies to sensor_data_out.invalidvalue;
		**};
	end gps_rt;
	
	device implementation gps_rt.impl extends sensor::generic_sensor.impl
	end gps_rt.impl;
	
	system gps_handler extends sensor::generic_sensor_handler
	end gps_handler;
	
	system implementation gps_handler.impl extends sensor::generic_sensor_handler.impl
	end gps_handler.impl;
	
	-- speedometer
	device speedometer_rt extends sensor::generic_sensor
		features
			sensor_data_out: refined to out data port data_types::speed;
			BA: requires bus access platform::generic_bus{SEI::PowerBudget=>5.0W;};
		
		annex EMV2 {**
			use types error_library;	
				error propagations
				sensor_data_out : out propagation {InvalidValue};
			flows
				ef0 : error source sensor_data_out{InvalidValue};
			end propagations;
		
			properties	
				emv2::hazards => 
					([	failure => "InvalidValue";
						description => "Invalid data sent by the speedometer";
					])
					applies to sensor_data_out.invalidvalue;
		**};
	end speedometer_rt;
	
	device implementation speedometer_rt.impl extends sensor::generic_sensor.impl
	end speedometer_rt.impl;
	
	system speedometer_handler extends sensor::generic_sensor_handler
	end speedometer_handler;
	
	system implementation speedometer_handler.impl extends sensor::generic_sensor_handler.impl
	end speedometer_handler.impl;
	
	-- user interface
	device user_interface_rt extends abstracts::user_interface
		features
			BA: requires bus access platform::generic_bus;
	end user_interface_rt;
	
	device implementation user_interface_rt.impl extends abstracts::user_interface.impl
	end user_interface_rt.impl;
	
	-- process 
	process control_rt extends controller::generic_controller
		features
			sensor1_data_in: refined to in data port data_types::radar_info;
			sensor2_data_in: refined to in data port data_types::picture;
			sensor3_data_in: refined to in data port data_types::gpsPosition;
			sensor4_data_in: refined to in data port data_types::speed;
			brake_failed:    refined to in event data port;
		
			
			annex EMV2 {**
			use types     error_library;
			use behavior  error_library::stateMachine;
			
		**};
			
	end control_rt;
	
	process implementation control_rt.impl extends controller::generic_controller.threads
		subcomponents
			thread_radar:      refined to thread read_radar.impl {Classifier_Substitution_Rule => Type_Extension;}; -- in modes (acc,cacc, cc, failure);
			thread_camera:     refined to thread read_camera.impl {Classifier_Substitution_Rule => Type_Extension;};
			thread_gps:    	   refined to thread read_gps.impl    {Classifier_Substitution_Rule => Type_Extension;};
			thread_speedometer: refined to thread read_speedometer.impl  {Classifier_Substitution_Rule => Type_Extension;};
			thread_controller: refined to thread thread_controller.impl  {Classifier_Substitution_Rule => Type_Extension;};
			control_modal: 	   refined to thread control_modal.impl  	 {Classifier_Substitution_Rule => Type_Extension;};
		connections
			-- connect process w/ threads A,B,C
			radar_thread_conn: 			port sensor1_data_in->thread_radar.sensor_in;
			camera_thread_conn: 		port sensor2_data_in->thread_camera.sensor_in;
			gps_thread_conn: 			port sensor3_data_in->thread_gps.sensor_in;
			speedometer_thread_conn: 	port sensor4_data_in->thread_speedometer.sensor_in;
			
			-- connect threads A,B,C w/ thread D
			radar_controller_conn:		port thread_radar.sensor_out->thread_controller.data_in;
			camera_controller_conn:		port thread_camera.sensor_out->thread_controller.data_in;
			gps_controller_conn:		port thread_gps.sensor_out->thread_controller.data_in;
			speedometer_controller_conn:port thread_speedometer.sensor_out->thread_controller.data_in;
			
			-- connect thread C w/ thread D	
			threads_conn: 				port thread_controller.data_out->control_modal.sensor_data;
			-- connect UI w/ thread E (control_modal)
			UI_conn:					feature group UI_inverse_ports -> control_modal.UI_ports;
			-- connect E w/ process
			
			modal_proc_conn:			port control_modal.feedback->feedback;
			preferences_conn:			port preferences.speed_limit->control_modal.speed_limit;
			-- connect modal w/ process
			modal_coon: 				port control_modal.cmd -> current_speed;
			brake_conn:					port brake_failed->control_modal.brake_failed;
			
		flows	
			UI_sink    		 : flow sink UI_inverse_ports -> UI_conn -> control_modal.UI_sink;
			
			controller_path0a : flow path sensor1_data_in -> radar_thread_conn -> thread_radar.thread_path0 -> radar_controller_conn
				-> thread_controller.controller_thread_path0 -> threads_conn -> control_modal.control_modal_path0 ->modal_coon -> current_speed; 
	
			controller_path1a : flow path sensor2_data_in -> camera_thread_conn -> thread_camera.thread_path0 -> camera_controller_conn
							-> thread_controller.controller_thread_path0 -> threads_conn -> control_modal.control_modal_path0 ->modal_coon -> current_speed; 
			controller_path2a : flow path sensor3_data_in -> gps_thread_conn -> thread_gps.thread_path0 -> gps_controller_conn
								-> thread_controller.controller_thread_path0 -> threads_conn -> control_modal.control_modal_path0 ->modal_coon -> current_speed;  
			controller_path3a : flow path sensor4_data_in -> speedometer_thread_conn -> thread_speedometer.thread_path0 -> speedometer_controller_conn
								-> thread_controller.controller_thread_path0 -> threads_conn -> control_modal.control_modal_path0 ->modal_coon -> current_speed;  
			
			controller_path0b : flow path sensor1_data_in -> radar_thread_conn -> thread_radar.thread_path0 -> radar_controller_conn
				-> thread_controller.controller_thread_path0 -> threads_conn -> control_modal.control_modal_path1 ->modal_proc_conn -> feedback; 
	
			controller_path1b : flow path sensor2_data_in -> camera_thread_conn -> thread_camera.thread_path0 -> camera_controller_conn
			    -> thread_controller.controller_thread_path0 -> threads_conn -> control_modal.control_modal_path1 ->modal_proc_conn -> feedback;
	
			controller_path2b : flow path sensor3_data_in -> gps_thread_conn -> thread_gps.thread_path0 -> gps_controller_conn
					-> thread_controller.controller_thread_path0 -> threads_conn -> control_modal.control_modal_path1 ->modal_proc_conn -> feedback;  
			
			controller_path3b : flow path sensor4_data_in -> speedometer_thread_conn -> thread_speedometer.thread_path0 -> speedometer_controller_conn
								-> thread_controller.controller_thread_path0 -> threads_conn -> control_modal.control_modal_path1 ->modal_proc_conn -> feedback;  
		
		modes
			manual: initial mode;
			cc: mode;
			acc: mode;
			cacc: mode;	
			failure: mode;
			
			-- turn on/off	
			manual -[UI_inverse_ports.turn_on_off]-> cc;
			
			-- cc
			cc -[UI_inverse_ports.set_speed_down]-> cc;
			cc -[UI_inverse_ports.turn_on_off]->   manual;
			cc -[UI_inverse_ports.set_speed_up]-> cc;
			cc -[UI_inverse_ports.set_speed_down]-> manual;
			cc -[brake_failed]-> failure;
			
			-- acc
			acc -[UI_inverse_ports.set_level_up]->  cacc;
			acc -[UI_inverse_ports.set_level_down]-> cc;
			acc -[UI_inverse_ports.turn_on_off]->  manual;
			acc -[UI_inverse_ports.set_gap]->  acc;
			acc  -[brake_failed]-> failure;
			-- acc -[RadioData]-> cacc;
			
			-- cacc
			cacc-[UI_inverse_ports.set_level_down]-> acc;
			cacc -[UI_inverse_ports.turn_on_off]-> manual;
			cacc -[brake_failed]-> failure;
			-- cacc -[NoRadioData]-> acc;
				
		properties
      		SEI::MIPSBudget => 1350.0 MIPS;
      		SEI::RAMBudget => 1350.0 MByte;						
	end control_rt.impl;
	
	-- process preferences
	process preferences extends controller::preferences
	end preferences;
	
	process implementation preferences.impl
		properties
      		SEI::MIPSBudget => 1350.0 MIPS;
      		SEI::RAMBudget => 1350.0 MByte;
	end preferences.impl;
	
	-- threads 
	thread read_radar extends controller::read_sensor
		features
			sensor_in:   refined to in data port data_types::radar_info;
	end read_radar;
	
	thread implementation read_radar.impl
	end read_radar.impl;
	
	thread read_camera extends controller::read_sensor
		features
			sensor_in:   refined to in data port data_types::picture;
	end read_camera;
	
	thread implementation read_camera.impl
	end read_camera.impl;
	
	thread read_gps extends controller::read_sensor
		features
			sensor_in:   refined to in data port data_types::gpsPosition;
	end read_gps;
	
	thread implementation read_gps.impl
	end read_gps.impl;
	
	thread read_speedometer extends controller::read_sensor
		features
			sensor_in:   refined to in data port data_types::speed;
	end read_speedometer;
	
	thread implementation read_speedometer.impl
	end read_speedometer.impl;
	
	thread thread_controller extends controller::thread_controller
	features
		data_in:   refined to in data port;
	end thread_controller;
	
	thread implementation thread_controller.impl 
	end thread_controller.impl;
	
	thread control_modal extends controller::control_modal
		features
			brake_failed:  in event port;
	end control_modal;
	
	thread implementation control_modal.impl 
	end control_modal.impl;
	
	system logger_rt extends abstracts::logger
	end logger_rt;
	
	system implementation logger_rt.impl extends abstracts::logger.impl
	end logger_rt.impl;
	
	-- device throttle
	device throttle_actuator_rt extends abstracts::throttle_actuator
		features
			cmdThrottle: 	   in data port data_types::cmd;
			failed: refined to  out event port;
	--	annex AGREE{**
	--		assume "cmdThrottle must be positive":cmdThrottle::value > 0;
	--		guarantee "":;
			
	--		**}
	end throttle_actuator_rt;
	
	device implementation throttle_actuator_rt.impl extends abstracts::throttle_actuator.impl
	end throttle_actuator_rt.impl;
	
	-- device brake
	device brake_rt extends abstracts::brake
		end brake_rt;
	
	device implementation brake_rt.impl extends abstracts::brake.impl
	end brake_rt.impl;
	
	-- process interface controller
	process interface_controller_rt extends abstracts::interface_controller
	end interface_controller_rt;
	
	process implementation interface_controller_rt.impl extends abstracts::interface_controller.impl
		properties
      		SEI::MIPSBudget => 1350.0 MIPS;
      		SEI::RAMBudget => 1350.0 MByte;
	end interface_controller_rt.impl;
	
	-- process speed controller
	process speed_controller_rt extends controller::speed_controller
	end speed_controller_rt;
	
	process implementation speed_controller_rt.impl extends controller::speed_controller.impl
		properties
      		SEI::MIPSBudget => 1350.0 MIPS;
      		SEI::RAMBudget => 1350.0 MByte;
	end speed_controller_rt.impl;
	
end integration;
